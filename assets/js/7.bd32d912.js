(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{360:function(e,s,t){e.exports=t.p+"assets/img/binary-expression-tree-example.1a3312b3.svg"},375:function(e,s,t){"use strict";t.r(s);var a=t(44),r=Object(a.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expression"}},[e._v("#")]),e._v(" Expression")]),e._v(" "),a("p",[e._v("An expression is a combination of variables, primitives, operators and functions that are evaluated to get their value. The evaluation is done in a specific order.")]),e._v(" "),a("h2",{attrs:{id:"order-of-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#order-of-operations"}},[e._v("#")]),e._v(" Order of operations")]),e._v(" "),a("p",[e._v("The order of operations is used when evaluating an expression to determine which procedure to perform first. This impacts the result of an expression. A simple example is "),a("code",[e._v("1 + 2 * 3")]),e._v(" versus "),a("code",[e._v("(1 + 2) * 3")]),e._v(" . Both expressions have a different result because the order of operations prioritizes parentheses.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("N.")]),e._v(" "),a("th",[e._v("Operation token")]),e._v(" "),a("th",[e._v("Context")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("1")]),e._v(" "),a("td",[e._v("( expression )")]),e._v(" "),a("td",[e._v("Parentheses")])]),e._v(" "),a("tr",[a("td",[e._v("2")]),e._v(" "),a("td",[e._v("name()")]),e._v(" "),a("td",[e._v("Function call")])]),e._v(" "),a("tr",[a("td",[e._v("3")]),e._v(" "),a("td",[e._v("- + !")]),e._v(" "),a("td",[e._v("Unary operators")])]),e._v(" "),a("tr",[a("td",[e._v("4")]),e._v(" "),a("td",[e._v("^")]),e._v(" "),a("td",[e._v("Involution")])]),e._v(" "),a("tr",[a("td",[e._v("5")]),e._v(" "),a("td",[e._v("* / %")]),e._v(" "),a("td",[e._v("Multiplication, division, modulo")])]),e._v(" "),a("tr",[a("td",[e._v("6")]),e._v(" "),a("td",[e._v("+ -")]),e._v(" "),a("td",[e._v("Addition and subtraction")])]),e._v(" "),a("tr",[a("td",[e._v("7")]),e._v(" "),a("td",[e._v("== != <= >= < >")]),e._v(" "),a("td",[e._v("Comparisons")])]),e._v(" "),a("tr",[a("td",[e._v("8")]),e._v(" "),a("td",[e._v("&&")]),e._v(" "),a("td",[e._v("Logical AND")])]),e._v(" "),a("tr",[a("td",[e._v("9")]),e._v(" "),a("td",[e._v("||")]),e._v(" "),a("td",[e._v("Logical OR")])]),e._v(" "),a("tr",[a("td",[e._v("10")]),e._v(" "),a("td",[e._v("= += -= *= /= %= ^=")]),e._v(" "),a("td",[e._v("Assignment operators")])]),e._v(" "),a("tr",[a("td",[e._v("11")]),e._v(" "),a("td",[e._v("1, true, name")]),e._v(" "),a("td",[e._v("Identifier & Literal  (terms)")])])])]),e._v(" "),a("p",[a("sub",[e._v("This list is still in concept and will subject to change")]),a("br"),e._v(" "),a("sub",[e._v("See "),a("RouterLink",{attrs:{to:"/syntax/operators.html"}},[e._v("operators")]),e._v(" for details about the operators.")],1)]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("identifier_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("literal_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("binary_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("unary_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("grouping_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("assignment_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("h2",{attrs:{id:"identifier-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#identifier-expression"}},[e._v("#")]),e._v(" Identifier expression")]),e._v(" "),a("p",[e._v('Identifiers are references to the name of a variable declared inside of a scope. These share a spot in the order of operations with literals under the combined name "terms". Identifier expressions cannot exist on their own and are always nested within other expressions.')]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("identifier_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ttr extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var foo = 12\nfoo = 2\n\n// "foo" is the identifier expression nested in the assignment expression "foo = 2".\n\nval bar = foo / 7\n\n// "foo" and "bar" are both identifier expressions nested within an expression tree.\n')])])]),a("h2",{attrs:{id:"literal-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#literal-expression"}},[e._v("#")]),e._v(" Literal expression")]),e._v(" "),a("p",[e._v("Literals are expressions based on a single item, similar to identifiers. A literal value is a primitive like: "),a("code",[e._v("1")]),e._v(", "),a("code",[e._v("true")]),e._v(", "),a("code",[e._v("false")]),e._v(", or a "),a("code",[e._v("'string'")]),e._v('. Literals share a spot in the order of operations with identifiers under the combined name "terms". Like identifiers, these cannot exist on their own and are always nested within another expression.')]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("literal_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("boolean")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("integer")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("string")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[a("sub",[e._v("See "),a("RouterLink",{attrs:{to:"/syntax/primitives.html"}},[e._v("primitives")]),e._v(" for details about primitives.")],1)]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ttr extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var foo = 12\nfoo = 2\n\n// 12 and 2 are both literal expressions.\n\nval bar = foo / 7\n\n// 7 is a literal expression.\n\nvar baz = true\nbaz = false\n\n// true and false are both literal expressions.\n\nvar quux = 'Niels'\nquux = 'Marnix'\n\n// 'Niels' and 'Marnix' are both literal expressions.\n")])])]),a("h2",{attrs:{id:"binary-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-expression"}},[e._v("#")]),e._v(" Binary expression")]),e._v(" "),a("p",[e._v("Used in performing an operation on two expressions. These are used to build the expression tree. The last leaf within the tree will always be a term (identifier or literal). Binary expressions are used for mathematical operations, logic operations, assignment expressions and any valid combination between these. Binary expressions follow the "),a("a",{attrs:{href:"#order-of-operations"}},[e._v("order of operations")]),e._v(".")]),e._v(" "),a("p",[e._v("Binary expressions consist of a left- and right-side expression. For lines containing multiple operations a binary expression tree is build which can go to a very deep nesting of expressions.")]),e._v(" "),a("p",[e._v("Expression: (a + b) * c + 7")]),e._v(" "),a("img",{attrs:{src:t(360),alt:"Expression tree of the expression (a + b) * c + 7",width:"500",height:"500"}}),e._v(" "),a("p",[a("sub",[e._v("Expression tree - from "),a("a",{attrs:{href:"https://commons.wikimedia.org/wiki/File:Exp-tree-ex-11.svg",target:"_blank",rel:"noopener noreferrer"}},[e._v("Wikimedia"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("More information about expression trees and their working can be found on the "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Binary_expression_tree",target:"_blank",rel:"noopener noreferrer"}},[e._v("Wikipedia article"),a("OutboundLink")],1),e._v(" on binary expression trees.")]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("binary_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("operator")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[a("sub",[e._v("See "),a("RouterLink",{attrs:{to:"/syntax/operators.html"}},[e._v("operators")]),e._v(" for details on operators.")],1)]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ttr extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('val foo = 2 * 3\n\n// "2 * 3" is a binary expression of 2 terms with a multiply operation.\n\nval bar = foo / 1\n\n// "foo / 1" is a binary expression of 2 terms with a division operation.\n\nval baz = foo * bar + 12 / 2\n\n// "foo * bar + 12 / 2" is a binary expression tree root. Both the left and right side contain another binary expression.\n// The left side is "foo * bar" and the right is "12 / 2". Evaluating this will result in 42.\n')])])]),a("h2",{attrs:{id:"unary-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unary-expression"}},[e._v("#")]),e._v(" Unary expression")]),e._v(" "),a("p",[e._v("Used to apply a single operator to an expression like using a minus operator to invert the state of an mathematical expression.")]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("unary_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("minus")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("plus")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ttr extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('var foo = 12\nfoo = -foo\n\n// "-foo" is an unary expression that inverts the state of literal to a negative number.\n')])])]),a("h2",{attrs:{id:"grouping-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grouping-expression"}},[e._v("#")]),e._v(" Grouping expression")]),e._v(" "),a("p",[e._v("A grouping is used for telling the interpreter to resolve the grouped expression before others. This is helpful when resolving a nested expression with an higher order of operation before one with an lower order. Using the grouping expression to change the order of operations also change the outcome. A classic example of this is "),a("a",{attrs:{href:"https://pemdas.info",target:"_blank",rel:"noopener noreferrer"}},[e._v("PEMDAS"),a("OutboundLink")],1),e._v(" for basic mathematical expressions.")]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("grouping_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"("')]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('")"')]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ttr extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// Using the normal order of operations\n// "5 * 2" is evaluated before "1 + ".\n\n1 + 5 * 2 // = 11\n\n// Using the grouping expression\n// "(1 + 5)" is evaluated before "* 2".\n\n(1 + 5) * 2 // = 12\n')])])]),a("h2",{attrs:{id:"assignment-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assignment-expression"}},[e._v("#")]),e._v(" Assignment expression")]),e._v(" "),a("p",[e._v("Used for binding a result of an expression to a variable. This can be used in declarations and as an expression. It consists of the name of the variable that will bind the expression result, the type of assignment and a expression to evaluate. The expression is evaluated and assigned to the variable using the given operator type.")]),e._v(" "),a("p",[a("strong",[e._v("EBNF Notation")])]),e._v(" "),a("div",{staticClass:"language-ebnf extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ebnf"}},[a("code",[a("span",{pre:!0,attrs:{class:"token definition rule keyword"}},[e._v("assignment_expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("name")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("assignment_operator")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token rule"}},[e._v("expression")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ttr extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var foo = 1\nfoo = 2\n\n// foo = 2\n\nvar bar = 12\nbar += 4\n\n// bar = 16\n\nvar baz = 9\nbaz /= 3\n\n// baz = 3\n\nvar qux = 2\nqux ^= 8\n\n// qux = 256\n")])])]),a("p",[a("sub",[e._v("See "),a("RouterLink",{attrs:{to:"/syntax/variables.html"}},[e._v("variables")]),e._v(" for details about variables.")],1),a("br"),e._v(" "),a("sub",[e._v("See "),a("RouterLink",{attrs:{to:"/syntax/operators.html"}},[e._v("operators")]),e._v(" for details about operators.")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);